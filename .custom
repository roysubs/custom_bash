#!/bin/bash
####################
# git clone https://github.com/roysubs/custom_bash                          # cd into project: '. custom_loader.sh' to configure.
# git clone https://roysubs:<ghp_xxxxxxxx>@github.com/roysubs/custom_bash   # To clone with token
# . <(curl -sS https://raw.githubusercontent.com/roysubs/custom_bash/master/.custom)   # To dotsource from github immediately
# If working on a server, simply copy the contents of RAW .custom into a new file '.custom' in home folder then dotsource that
# https://raw.githubusercontent.com/roysubs/custom_bash/master/.custom
# .custom is always compatible with Ubuntu/Debian, RedHat/Fedora/CentOS, and Alpine. WSL extensions only instll if WSL is detected and include many tools to help with that setup.
# Maintain a clean, basic shell, i.e. Should not be something to become dependent upon, just techniques that help with complex commands and useful tools.
# Very lightweight, 'time . .custom' => real 0m0.533s (on 2013 Core i5), 'bash --norc', then 'ps -F' shows RSS 4132 for --norc vs 5888 for .custom, so +1.8 MB memory usage.
# Do not clutter up core config files. i.e. Only 2 lines are added to .bashrc to call .custom; just delete those lines to completely remove this prokect.
# Use of 'type' over 'which'? https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
# Various links to discussions use short notation, e.g. https://stackoverflow.com/q/7812324 is the same as https://stackoverflow.com/questions/7812324/finding-executable-files-using-ls-and-grep
# curl -s https://raw.githubusercontent.com/roysubs/custom_bash/master/custom_loader.sh | bash   # Alternative one-line installation.
# Avoid using aliases/functions that override other packages, unless those packages are redundant (e.g. 'ii' overrides an 'ii' IRC client which is of no use).
# Almost every function and alias is standalone; try not to build complex relationships (exception: 'ask' function used by 'mykill' as a demonstration)
# Do not replace built-in commands as would impact expected output in pipeline and scripts. Exceptions: 'cat' and 'more' in the below).
# Simple abbreviations/mnemonics for most aliases, ai='sudo apt install -y, tn='t'mux 'n'ew -s <session>, myip, etc
# Many aliases will not be created if the component that they rely upon is missing (i.e. standalone, can drop into a server and will work).

####################
# Using .custom tools: search for and show full definitions of any alias or function
####################
# 'aaff <string>' 'find functions/aliases, 'aaa <string>' 'find aliases', 'fff <string>' 'find functions'.
# e.g. 'aaff git', 'aaff netstat' show every function/alias containing 'git' or 'netstat'. Limited regex support, 'aaff ^g' works, but '*' in the body of a search does not.
# To get more detailed info on a function, use 'def <fnname>' to display the full definition of that function (or alias, but mostly use this for functions).
# Also remember just using 'grep netstat .custom' to view information, and the grep -A (after) / -B (before) to get context around the search results.
# Use     perl -pe 's/\e([^\[\]]|\[.*?[a-zA-Z]|\].*?\a)//g' | col -b     to remove color and control characters from output, https://unix.stackexchange.com/q/14684/
uncolor() { perl -pe 's/\e([^\[\]]|\[.*?[a-zA-Z]|\].*?\a)//g' | col -b; }   # Used by the 'fff' function below (and generally useful to remove control characters from files or pipeline output)
aaa() { if type bat > /dev/null 2>&1; then PAGER='bat -pp -l bash'; else PAGER='cat'; fi; if [ -z "$1" ]; then alias | $PAGER; else alias | sed 's/alias //g' | grep "$1" | $PAGER; fi; echo -e "\nAll aliases that contain a match for '$1'.\n"; }
fff() { if type bat > /dev/null 2>&1; then PAGER='bat -pp -l bash'; else PAGER='cat'; fi; if [ -z "$1" ]; then declare -F | awk '{print $3}' | $PAGER; else declare -f | awk -v srch="$1" 'NF==2 && $2=="()"{if (m) print buf; buf=""; m=0} index($0,srch){m=1} {buf=buf ORS $0} END{if (m) print buf}' | $PAGER; fi; echo -e "\nAll functions that contain a match for '$1'.\n"; }
aaff() { echo -e "\e[1;37m\nFunctions that contain '$1':\n____________________\n"; fff $1 | uncolor | grep \(\) | uncolor | grep -v "^[[:space:]]"; echo -e "\e[1;37m\n\nAliases that contain '$1':\n____________________\n"; aaa $1; }   # Just show the names of functions that contain the search-string
alias ffaa='aaff'
def() { if [ -z "$1" ]; then declare -F; printf "\nAbove listing is all defined functions 'declare -F' (use def <func-name> to show function contents)\nType 'alias' to show all aliases (def <alias-nam> to show alias definition, where 'def' uses 'command -V <name>')\n\n"; elif type bat >/dev/null 2>&1; then command -V $1 | bat -pp -l bash; else command -V $1; fi }
# ToDo: Parse script for aliases and functions'  :  paf() { if [ -z "$1" ]; then echo "Require a filename to parse for aliases and functions"; else grep -o '\w*\w\s*\(\)' $1 | sed -E 's/\s*\(\)//'; fi; }
# Show the definition of a command/function/alias. Also note: command -v, type <aliasname>, bash -xl^C
# def() { if [ -z "$1" ]; then declare -F; printf "\nAbove listing is all defined functions 'declare -F' (use def <func-name> to show function contents)\nType 'alias' to show all aliases (def <alias-nam> to show alias definition, where 'def' uses 'command -V <name>')\n\n"; elif type bat >/dev/null 2>&1; then command -V $1 | bat -pp -l bash; else command -V $1; fi; fi; }

####################
# Key Bindings: A good read here https://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc/
####################
# Bash completiion. e.g. Type 'tou', then press Tab twice (or Esc four times), it will complete the command ('touch'), or show all completion options if there is more than one.
# Alias expansion is important when using the below tools; "Esc, then Ctrl-e" (Ctrl-Alt-l is additionally added via custom_loader.sh into .inputrc), will expand any alias to its full definition on the terminal. https://superuser.com/questions/247770/how-to-expand-aliases-inline-in-bash
# Ctrl-l  : Does not clear the screen, but pushes current prompt line to top of screen (so looks like it is clearing screen, but not really, just scroll up to see previous commands). Useful for focus.
# Ctrl-xx : Toggle between start and end of the line, useful on long lines to flip to start, insert 'sudo', then flip to end and continue typing the command
# Alt-t to flip words, Ctrl-t to flip characters. If you try to type 'git' but instead type 'gti', press Ctrl-t to flip the last two characters, Alt-t does same but for last 2 words.
# Suspend/resume (Ctrl-s and Ctrl-q) can be useful when paging lots of info and you don't want to press Ctrl-c to read the output, but can be disabled with this if required (can be confusing when people accidentally press Ctrl-s and think the system has hung). It can be disabled with: stty -ixon / stty ixon to re-enable.
# Ctrl-r is quite specific; use only in one of two ways. 1. Type part of a command, then Ctrl-r, then Ctrl-p (previous) or Ctrl-n (next/forward), *or* PgUp/PgDn (additional option set by custom_loader.sh in .inputrc)
#    *or* 2. Press Ctrl-r on an *empty* line, (reverse-i-search)`' will appear, then type part of a command (the `' will populate), after this, only Ctrl-r or Ctrl-? will work (Ctrl-p/n or PgUp/PgDn do not seem to work in this mode).
# Some shell details:     https://devhints.io/bash
# https://unix.stackexchange.com/questions/159513/what-are-the-shells-control-and-redirection-operators
# https://unix.stackexchange.com/questions/230330/what-does-do                 bash -xl (what does it do?)

####################
# Basic Environment:   ('export' variable are available in all child processes. Without 'export', the variable will not be available outside of this script) https://stackoverflow.com/a/21722203/524587
####################
# If this is an xterm set the title to user@host:dir
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then . /etc/bash_completion; fi
case "$TERM" in
    xterm*|rxvt*|screen*)    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'    ;;
esac
# make less more friendly for non-text input files, see lesspipe(1), i.e. man 1 lesspipe
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"
[[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && . /usr/share/bash-completion/bash_completion   # Required by exa and various other tools. 
# Auto-cd (only for bash v4 and above). Type a directory name to cd into it, without needing to prefix it with 'cd'
[ $SHELL == "/bin/bash" ] && [ ${BASH_VERSINFO[0]} -ge 4 ] && shopt -s autocd   # Add shell test as otherwise /bin/ash breaks on the ${} construct
shopt -s checkwinsize   # At every prompt check if the window size has changed
shopt -s histappend;   # Append commands to the bash history (~/.bash_history) instead of overwriting it   # https://www.digitalocean.com/community/tutorials/how-to-use-bash-history-commands-and-expansions-on-a-linux-vps
export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"   # -a append immediately, then  -c clear history, then -r read history every time a prompt is shown instead of after closing the session.
export HISTTIMEFORMAT="%F %T  " HISTCONTROL=ignorespace:ignoreboth:erasedups HISTSIZE=1000000 HISTFILESIZE=1000000000   # make history very big and show date-time when run 'history'
# history 7 (last 7 lines), !51 (run command 51 in history), !-3 (run 3rd last command), !! (or !-1) run last command, su -c "!!" root,  switch user to root and run last command
#   touch a.txt b.txt c.txt; echo !^; echo !:1; echo !:2; echo !:3; echo !$; echo !*
#   rm !(abc.txt)   remove everything except abc.txt      rm !(*.pdf)   remove everything except pdf files
#   !# (retype from current line)    cp /some/long/path/file !#:1 (now press tab and it will expand)
# Event Designators: !?grep? (last command with 'grep' somewhere in the body), !ssh (last command starting 'ssh')
#   !?torn  (grep for last command with 'torn' in the body),   wc !?torn:2   (run wc using the 2nd argument of the last command with 'torn' in body)
# Word Designatores: ls /etc/, cd !!:1 (:0 is the initial word), !!:1*, !!:1-$, !!:*     'cat /etc/hosst', then type '^hosst^hosts^' will immediately run the fixed command.
# Modifiers: 'cat /etc/hosts', cd !!:$:h (will cd into /etc/ as :h chops the 'head' off, :t, 'tail' will remove 'cat /etc/', :r to remove trailing extension, :r:r to remove .tar.gz, :p is just to 'print', 'find ~ -name "file1"', try !119:0:p / !119:2*:p
alias h='history'   # Note: 'h 7' to show last 7 lines
alias ho='HISTTIMEFORMAT= history'   # 'history original', can also use constructs like:  ho() { history "$@" | awk '{$2=$3=""; print}'; }   # for i in $(seq 1 9); do alias "h.${i}"="h. | tail -${i}0"; done   # Replicate original history (i.e. without date/time), and h.1 to h.9 for multiples of 10 lines
hh() { history "$@" | awk '{$1=$2=$3=""; print $0}' | sed 's/^[ \t]*/# /;s/[ \t]*$//'; }     # 'hash history', output preformated for documentation etc   
hx() { hh | sed 's/^#\ //'; }   # 'history executable', this variant is just the raw and executable (hence 'x') commands; be careful as easy to copy and run these
alias hs='history | grep'; alias hs1='history | grep -A 1 -B 1'; alias hs2='history | grep -A 2 -B 2'    # Search history, optionally hs1/hs2 with 1/2 line 'A'bove and 1/2 line 'B'elow each match (for context of the command
alias hhs='hh | grep'; alias hhs1='hh | grep -A 1 -B 1'; alias hhs2='hh | grep -A 2 -B 2'    # Search history but in 'hash history' format, with grep search
alias hxs='hx | grep'; alias hxs1='hx | grep -A 1 -B 1'; alias hxs2='hx | grep -A 2 -B 2'    # Search history but in 'history executable' format, with grep search

export LS_COLORS=$LS_COLORS:'di=0;94'  # Windows setups can find it difficult to display dark blue on black, so change to bright blue "0;94"
alias blue_console='export LS_COLORS=$LS_COLORS:"di=0;36"'  # If SSH to Linux from PowerShell, console has blue background, so adjust folder colour to dark cyan "0;36"
# Alter PS1 (prompt). With this, non-root users display in green, but root will display in red, # \[\033[00m\]@ (white), [\033[01;33m\] \h (cyan hostname), [\033[01;36m\] \w (yellow directory)
export PS1="\[\033[01;$(if [ $(id -u) -eq 0 ]; then echo "31m"; else echo "32m"; fi)\]\u\[\033[00m\]@\[\033[01;33m\]\h\[\033[00m\]:\[\033[01;36m\] \w\[\033[00m\] \$ "
# Set default $EDITOR and $VISUAL to vim (as Ubuntu defaults to nano for 'sudo visudo' etc). https://unix.stackexchange.com/questions/73484/how-can-i-set-vi-as-my-default-editor-in-unix
# Also note: select-editor   # update-alternatives --config editor   # update-alternatives --list editor   # type update-alternatives &> /dev/null && update-alternatives --set editor /usr/bin/vim.basic
export EDITOR=vim; export VISUAL=vim

# Standard color for LESS/MAN pages (following was only way that I found that was cross-distro compatible, e.g. CentOS does not have by default)
export LESS_TERMCAP_mb=$'\E[1;31m'; export LESS_TERMCAP_md=$'\E[1;36m'; export LESS_TERMCAP_me=$'\E[0m' # begin bold, begin blink, reset bold/blink
export LESS_TERMCAP_so=$'\E[01;44;33m'; export LESS_TERMCAP_se=$'\E[0m'; export LESS_TERMCAP_us=$'\E[1;32m' # begin reverse video, reset reverse video, begin underline
export LESS_TERMCAP_ue=$'\E[0m'; export GROFF_NO_SGR=1 # reset underline, not for putty (konsole and gnome-terminal)

# Some colors might look different on some terminals, e.g. 'Bold Red' can look orange on some screens (taken from Color Bash Prompt HowTo).
Black='\e[0;30m'; Red='\e[0;31m'; Green='\e[0;32m'; Yellow='\e[0;33m'; Blue='\e[0;34m'; Purple='\e[0;35m'; Cyan='\e[0;36m'; White='\e[0;37m' # Normal colours and NC for 'no colour'
BBlack='\e[1;30m'; BRed='\e[1;31m'; BGreen='\e[1;32m'; BYellow='\e[1;33m'; BBlue='\e[1;34m'; BPurple='\e[1;35m'; BCyan='\e[1;36m'; BWhite='\e[1;37m'    # Bold
On_Black='\e[40m'; On_Red='\e[41m'; On_Green='\e[42m'; On_Yellow='\e[43m'; On_Blue='\e[44m'; On_Purple='\e[45m'; On_Cyan='\e[46m'; On_White='\e[47m'    # Background
NC="\e[m"; ALERT=${BWhite}${On_Red}   # NC for 'No Color' and ALERT for Bold White on red background.

s() { if [[ $# == 0 ]]; then sudo $(history -p '!!'); else sudo "$@"; fi; }   # sudo, *or* sudo the previous command if no argument is given (e.g. handy when do 'vim /etc/bashrc')
alias sudo='sudo '                      # Allows alias expansion even when using sudo, e.g. 'sudo t' will expand 't' to tmux, without this it will not see an alias for 't' https://stackoverflow.com/questions/37209913/how-does-alias-sudo-sudo-work
alias s!='eval "sudo $(fc -ln -1)"'     # "sudo last command", equal to "sudo !!". e.g. "vi /etc/hosts" is run but then see that it is read-only, so drop out, then "s!" to re-run elevated. 'fc' is a shell builtin used to list or edit and re-execute a portion of the history list (man bash for more). https://adamtheautomator.com/bash-fc-command/
complete -cf sudo    # Tab complete for commands that come after sudo

alias v='vim'                               # Quick vim access
type code &> /dev/null && alias c='code'    # Quick VS Code access
type byobu &> /dev/null && alias b='byobu'  # Quick byobu access
type tmux &> /dev/null && alias t='tmux'    # Quick tmux access
alias tn='echo "# tmux new -s <name>"; tmux new'   # Syntax reminder for the -s (short for -session_name)
alias ta='echo "# tmux a -t <name>"; tmux a'       # Syntax reminder, using -t (for -target_session)
alias td='echo "# tmux d or detach"; tmux detach'  # Syntax reminder for the -t (short for -target_session)
alias cls='clear'                       # DOS equivalent
alias cp.='rsync -ah --info=progress2'  # Use similar to 'cp' but with progress bar during copy (alternatively, install 'pv')
alias fhere="find . -name "             # Basic find syntax
ff() { find . -type f -iname '*'"$*"'*' -ls ; }   # 'Find in gilename', return files with pattern in the filename
fe() { find . -type f -iname '*'"${1:-}"'*' -exec ${2:-file} {} \;  ; }   # 'Find and Execute', find files with pattern $1 in name and execute $2 on them, note that if $2 is not ther, 'file' will be the default
alias folders='find . -maxdepth 1 -type d -print0 | xargs -0 du -sk | sort -rn'  # find in 1 deep, sort by size
alias mnt="mount | awk -F' ' '{ printf \"%s\t%s\n\",\$1,\$3; }' | column -t | egrep ^/dev/ | sort"   # Show only mounted drives
alias mountt='mount | columns -t'                        # 'mount with tabs' to make mount readable
alias bashrc='vim ~/.bashrc && source ~/.bashrc'         # Edit ~/.bashrc and then source it on finishing editing
alias ps2='ps -ef | grep -v $$ | grep -i'                # Search processes for a string
alias psg='ps -Helf | grep -v $$ | grep -i -e WCHAN -e'  # Search processes for a string
alias tree-all="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"
alias tree-dir="ls -R | grep :*/ | grep ":$" | sed -e 's/:$//' -e 's/[^-][^/]*//--/g' -e 's/^/   /' -e 's/-/|/'"
alias bigfiles="find . -type f 2>/dev/null | xargs du -a 2>/dev/null | awk '{ if ( \$1 > 5000) print \$0 }'"
alias verybigfiles="find . -type f 2>/dev/null | xargs du -a 2>/dev/null | awk '{ if ( \$1 > 500000) print \$0 }'"
alias watchtail='watch -n .5 tail -n 20'          # could use -f 'follow' but doesn't refresh like this
alias watchdir='watch -n .5 ls -la'               # same for dir
alias watchsize='watch -n .5 du -h –max-depth=1'  # same for size
alias brokenlinks='find . -xtype l -printf "%p -> %ln"'   # Find broken symlinks
ww() { if [[ ! -z $1 ]];then _f=$(which $1);echo $_f;less $_f;fi }   # which and less a script (ie. ww backup.ksh)
alias vimother="vim -u /home/username/.vimrc"     # use the .vimrc from another location
alias dmesg1='dmesg | perl -ne "BEGIN{$a= time()- qx:cat /proc/uptime:};s/[s*(d+).d+]/localtime($1 + $a)/e; print $_;" | sed -e "s|(^.*"`date +%Y`" )(.*)|x1b[0;34m1x1b[0m - 2|g"'
alias meminfo='\egrep "Mem|Cache|Swap" /proc/meminfo'
myusb() { usb_array=();while read -r -d $'n'; do usb_array+=("$REPLY"); done < <(find /dev/disk/by-path/ -type l -iname *usb*scsi* -not -iname *usb*scsi*part* -print0 | xargs -0 -iD readlink -f D | cut -c 8) && for usb in "${usb_array[@]}"; do echo "USB drive assigned to sd$usb"; done; }   # USB assigments
alias top10="sort|uniq -c|sort -n -r|head -n 10"
alias lu="awk -F: ‘{ print $1}’ /etc/passwd"
alias reboot1='echo "Are you sure you want to reboot \"`hostname`\" [y/N]?" && read reboot_answer && if [ "$reboot_answer" == y ]; then /sbin/reboot; fi'
alias shutdown1='echo "Are you sure you want to shutdown host \"`hostname`\" [y/N]?" && read shutdown_answer && if [ "$shutdown_answer" == y ]; then /sbin/shutdown -h now; fi'
alias tolowercase='tr "[:upper:]" "[:lower:]"'
alias touppercase='tr "[:lower:]" "[:upper:]"'

alias pbcopy='xclip -selection clipboard'; alias pbpaste='xclip -selection clipboard -o'  # To use xclip for copy/paste
alias pbcopy='xsel --clipboard --input';   alias pbpaste='xsel --clipboard --output'      # To use xsel for copy/paste    # alias c='xsel --clipboard'   # Copy from cli to clipboard, use like:   cat somefile | c
alias clipboardtolowercase='pbpaste | tr "[:upper:]" "[:lower:]" | pbcopy'   # whatever is in the X clipboard will be changed to lowercase
alias clipboardtouppercase='pbpaste | tr "[:lower:]" "[:upper:]" | pbcopy'   # whatever is in the X clipboard will be changed to lowercase

alias hogs='ps uxga | sort --key=3.1 -n'
alias sdiff='sdiff -w 240'
pyloc() { egrep -v '^[ ]*(#|$dollar)' $* | wc; };     # count lines in python / shell / powershell files
loc() { egrep -v '^[ ]*(//|/*|*|$dollar)' $* | wc; }; # count lines in c, c++ files

# Tab competion
[ -f ~/.ssh/known_hosts ] && complete -W "$(echo `cat ~/.ssh/known_hosts | cut -f 1 -d ' ' | sed -e s/,.*//g | uniq | grep -v "\["`;)" ssh   # Tab completion for ssh hosts
alias sshcachingagent='eval $(ssh-agent) && ssh-add'     # Make sure ssh-agent is running and then add a remote host
generatesshkey() {    # generatesshkey ansible
    echo -e "ssh-keygen Setup (rsa 4096 bit)\n\nssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa_<name>\n( ssh-keygen -t dsa  ,  ssh-keygen -t ecdsa -b 521  ,  ssh-keygen -t ed25519 )\nssh-copy-id - ~/.ssh/id_rsa_$name 192.168.1.11   # To send to other hosts"
    echo "Enter the name of the Key (no spaces) ? "; read name
    echo "Enter the email associated with it ? "; read email
    echo "Creating 4096 bit rsa ..."
    ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa_$name -C "$email"
    type pbcopy &> /dev/null && pbcopy < ~/.ssh/id_rsa_$name.pub && echo "SSH Key copied to clipboard by pbcopy" # pbcopy will copy into GUI clipboard if available (name comes from MacOS tool)
    eval $(ssh-agent)
    cat ~/.ssh/authorized_keys
}

generaterandompasswd() {
    if [ -z $1 ]; then MAXSIZE=10; else MAXSIZE=$1; fi
    array1=( q w e r t y u i o p a s d f g h j k l z x c v b n m Q W E R T Y U I O P A S D 
             F G H J K L Z X C V B N M 1 2 3 4 5 6 7 8 9 0 \! \@ \$ \% \^ \& \* \! \@ \$ \% \^ \& \* \@ \$ \% \^ \& \* ) 
    MODNUM=${#array1[*]};
    pwd_len=0 
    while [ $pwd_len -lt $MAXSIZE ] 
    do 
        index=$(($RANDOM%$MODNUM)) 
        echo -n "${array1[$index]}" 
        ((pwd_len++)) 
    done 
    echo 
}

####################
# ls, cd, mkdir, du, df, and permissions
####################
# Attempt to have a standard set of 'ls' outputs (as are often setup differently on each distribution).
# The [] 'character set wildcards'. e.g. ls name[03][17].c, would match name01.c, name07.c, name31.c, name37.c, and [] also allows ranges: ls name[07][1-9].c
# Note the use of '\ls' to run the bare command, ignoring an alias.
# The -F flag appends an indicator (one of */=>@|) to entries
# color=always vs color=auto: https://unix.stackexchange.com/questions/19317/can-less-retain-colored-output/19320#19320
# 'ls' is quite awkward with respect to recursion, e.g. 'ls *' will look into every subfolder even without the -R flag, and 'ls c*' would look through every folder starting 'c': https://unix.stackexchange.com/questions/179327/how-to-ls-without-recursive 
# Never use the output of an 'ls' in a 'for i in `ls`' as that can be unpredictable.
# Don't want to do anything obscure with aliases, follow widely used settings for ls, ll, l, then have additional aliases for other tasks.
[[ $(type ls) == *"aliased"* ]] && unalias ls               # Just a general way to testing for commands that are type 'alias' and so to act upon them if aliased
alias ls='\ls --color=always --group-directories-first'     # l will print the normal ls in most distros (i.e. will not show .* files!). Note that "\"" before a command revets a command back its non-aliased form
alias l='ls -AFh --color=always --group-directories-first'  # Using -A (almost all, ignores ./ and ../, but show all .* files, putting this to 'ls' as almost always wnat to see .* files)
alias la='ls -Ah'      # long format (-AFh and also -l)     # Note that the above "l" alias uses "\ls" to run ls bare without flags (to remove "-A" mainly)
alias ll='ls -lAh'     # long format (-AFh and also -l)     # Note that the above "l" alias uses "\ls" to run ls bare without flags (to remove "-A" mainly)
alias l.='ls -d .*'    # Explicitly list just .* files, so ./ and ../ are shown, overriding the A flag, -d list directories themselves, not their contents
alias ls.='ls -d .*'   # Explicitly list just .* files, so ./ and ../ are shown, overriding the A flag, long format, -d list directories themselves, not their contents
alias ll.='ls -dl .*'  # Explicitly list just .* files, so ./ and ../ are shown, overriding the A flag, long format, -d list directories themselves, not their contents
alias lld='ls -FlA | grep :*/'      # Directories only
alias llf='ls -FlA | grep -v "/"'   # Files only (no directories)
alias ldot="ls -ld .??*"            # Dotfiles only
alias lx="find . -maxdepth 1 -executable -type f"        # Executable files only, below 'lxext' is just trying to find 'executable-like' files by their extension
alias lnox="find . -maxdepth 1 -type f ! -executable"    # Everything except executable files   # alias lx="ls -FlA | grep *"; alias lnox="ls -FlA | grep -v *"
alias lxext='ll *.sh *.csh *.ksh *.c *.cpp *.py *.jar *.exe *.bat *.cmd *.com *.js *.vbs *.wsh *.ahk *.ps1 *.psm1 2> /dev/null'  # List possible executables and scripts by extensions, discarding error output (as will generate for every type that is not there)
alias lext='ls -Fla | egrep "\."'                        # Files without extensions only   ".|/"
alias lnoext='ls -Fla | egrep -v "\."'                   # Files without extensions only
alias lsp='find . -maxdepth 1 -perm -111 -type f'        # List executable by permissions.   ls -lsa | grep -E "[d\-](([rw\-]{2})x){1,3}"   https://stackoverflow.com/q/7812324
alias lsum="ls -Fla \$1 \$2 \$3 \$4 \$5  | awk '{ print; x=x+\$5 } END { print \"total bytes = \",x }'"   # ls on required info then awk will sum the sizes
alias lll='ls --human-readable --size -1 -S --classify'  # Long-list with just size and name and total size summary line
alias lm='ls -Am'; alias lcsv='lm'         # comma separated view (-m), -A almost all, except '.' and '..'
alias lsz='ls -lAshSr'; alias lsize='lsz'  # -s size, -h human readable, -S by size, -r reverse so largest are easily visible at end
alias lt='ls -lAth'  ; alias ltime='lt'; alias ldate='lt'; alias lst='lt'   # sort by -t time/date, hhuman readable
# replicate 'ls', but using 'stat' to show both normal 'ls' permission flags *and* octal.
lsec() { if [ -z "$@" ]; then args='. .*'; else args="$@"; fi; stat --printf="%A\t%a\t%h\t%U\t%G\t%s\t%.19y\t%n\n" $args; };   alias lstat='lsec';
lperm() { if [ -z "$@" ]; then args='. .*'; else args="$@"; fi; stat --printf="%A  %a  %n\n" $args; };   # Just permissions, %A (ls format), %a (Octal format) and names
sanitize() { chmod -R u=rwX,g=rX,o= "$@" ;}   # Make directory and file access rights the same
alias 000='echo "---------- (Owner -, Group -, and Other -)"; chmod 000'   # Remove permissions: append with file/directory to apply to
alias 644='echo "-rw-r--r-- (Owner rw, Group r, and Other r)"; chmod 644'  # Onwer rw, everyone else read-only
alias 755='echo "-rwxr-xr-x (Owner rwx, Group r-x, and Other r-x)"; chmod 755'  # Make executable, but only Owner has write permissions
alias mx='chmod a+x'   # Make Executable
alias lls='lss'        # Since the 'stat' output is in long format 'll', also use 'lls' for 'long listing with ecurity'
alias sl='ls'          # Common typo, also just overwrite the 'Steam Locotomive' toy, as that gets boring
alias lg='exa -lG'     # 'ls grid', exa is an interesting potential successor to 'ls', in Ubuntu 20.10 repo by default, colours each permission item and -lG is a useful 2x column long view.
cl() { cd "$@" && ls; }        # 'cd+ls'   -F --color=auto   # cl() { DIR="$*"; if [ $# -lt 1 ]; then DIR=$HOME; fi; builtin cd "${DIR}" && ls -F --color=auto; } # 'cd' into folder then 'ls' the contents
cll() { cd "$@" && ll; }       # 'cd+ll'
md() { [ $# = 1 ] && mkdir -pv "$@" && cd "$@" || echo "Error: no directory argument"; }  # 'mkdir' and then 'cd' into that directory
alias cd.='history | grep cd | grep -v cd$; echo -e "\n$(pwd)\n"'
alias cd-='cd -'; alias cd..='cd ..'; alias u1='cd ..'; alias u2='cd ../..'; alias u3='cd ../../..'; alias u4='cd ../../../../..'; alias u5='cd ../../../../../..'; alias u6='cd ../../../../../../..'
alias back='cd -'; alias cd-='cd -'; alias .1="cd .."; alias .2="cd ../.."; alias .3="cd ../../.."; alias .4="cd ../../../.."; alias .5="cd ../../../../.."; alias .6='cd ../../../../../../..'
alias most='du -hsx * | sort -rh | head -10'     # What is using the most space. Both directories and files. Varies on current directory
du.t() { du -hsc . ; }         # 'total' Just return a total size for everything under '.' (PWD) (including hidden, i.e. dot config files).
du.tsu() { sudo du -hsc . ; }  # 'all with sudo' Just return a total size for everything under PWD (including hidden, i.e. dot config files).
du.() { local dotglob=$(shopt -p dotglob); shopt -s dotglob; printf ""; du -hsc */ | sort -h; eval $dotglob; printf "\nSize of files in current directory only: $(ls -alc | grep ^total)\n\n"; } # du fixed (du is a broken command in my opinion, as it normally skips .* files/folders (which can often be very large so gives a warped representation of a folder size; this function fixes that).
du.m() { local dotglob=$(shopt -p dotglob); shopt -s dotglob; printf ""; sudo du -hsc */ | sort -h | grep -E ^[0-9]+?\.?[0-9]+M; eval $dotglob; printf "\nSize of files in current directory only: $(ls -alc | grep ^total)\n\n"; } # To further refine this e.g. to find only *folders* bigger than 1 MB, add to the du line: | grep -E ^[0-9]+?\.?[0-9]+G
du.g() { local dotglob=$(shopt -p dotglob); shopt -s dotglob; printf ""; sudo du -hsc */ | sort -h | grep -E ^[0-9]+?\.?[0-9]+G; eval $dotglob; printf "\nSize of files in current directory only: $(ls -alc | grep ^total)\n\n"; } # To further refine this e.g. to find only *folders* bigger than 1 GB, add to the du line: | grep -E ^[0-9]+?\.?[0-9]+G
du.su() { local dotglob=$(shopt -p dotglob); shopt -s dotglob; sudo du -hsc */ | sort -h; eval $dotglob; printf "\nSize of files in current directory only: $(ls -alc | grep ^total)\n\n"; }    # As for dufix(), but includes also inaccessible folders, so requiring 'sudo'
dus () { du --max-depth=0 -k * | sort -nr | awk '{ if($1>=1024*1024) {size=$1/1024/1024; unit="G"} else if($1>=1024) {size=$1/1024; unit="M"} else {size=$1; unit="K"}; if(size<10) format="%.1f%s"; else format="%.0f%s"; res=sprintf(format,size,unit); printf "%-4s %sn, ",res,$2 }'; echo; }
lsdu() { ls -l $* | sort --key=5.1 -n; };           # List by ascending size
lsduf() { ls -l | egrep $* | sort --key=5.1 -n; };  # Accepts input to fileter/grep on
alias duh='du -h --max-depth=1 | sort -h'
alias ducks='du -ck | sort -nr | head'           # Another way to find bloat (people say this link is 'shooting ducks' to find large size, silly name)
alias ducky='find . -maxdepth 1 -mindepth 1 -print0  | xargs -0 -n1 du -ks | sort -rn | head -16 | cut -f2 | xargs -i du -hs {}'   # An even more complex way to find bloat
alias usage1="du -h --max-depth=1 | sort -rh"    # Usage, 1 deep
alias usagehuman="du -h | tail -1 | cut -d$'\t' -f1"  # Grabs the disk usage in the current directory, note $'\t' to get tab as a delimeter for cut
alias usagebytes="du -c | tail -1 | cut -d$'\t' -f1"  # Just the value (human readable)
alias totalusage='df -hl --total | grep total'   # Gets the total disk usage on your machine
alias partusage='df -hlT --exclude-type=tmpfs --exclude-type=devtmpfs'   #Shows the individual partition usages without the temporary memory values
alias dfh="df -kh"
alias fs="df . | awk 'NR==2{print \$1}'"         # Show current filesystem that I am working in https://unix.stackexchange.com/q/164957/
 
# Be careful about defining single character aliases and functions, g=git could conflict with g=chrome etc
type git &> /dev/null && git config --global color.ui always && git config --global core.pager 'less -R'   # Enable git colour and to use less -R as pager https://unix.stackexchange.com/a/62850/441685
ghub="https://github.com"   # Usage:   gclone1 $ghub/roysubs/custom_bash
alias g='git'; alias gconf='git config'; alias gconfl='git config --list'; alias gconfgl='git config --global --list';
alias ggs="git status"; alias gga="git add"; alias ggc="git commit -m"; alias ggl='git log'; alias gcd0='cd `git rev-parse --show-toplevel`'   # Go to top of git project
alias ggps="git push origin master"; alias ggpl="git pull origin master"; alias ggsta='git stash'; alias ggstav='git -p status -vv'
alias gsetname='git config --global user.name $1'; alias gsetemail='git config --global user.email $1'; alias guser='git config --global user.name; git config --global user.email'
gclone() { git clone $1; cd $(echo $1 | rev | cut -d'/' -f1 | rev | cut -d'.' -f1); ls -al; }; alias gc='gclone'   # cd into the cloned project and ls, could be better to use  | grep -o '[^/]*$'  instead of rev/cut/rev/cut
gclone1() { git clone $1 --depth=1; cd $(echo $1 | rev | cut -d'/' -f1 | rev | cut -d'.' -f1); ls -al; }; alias gc1='gclone1'   # Almost never uesful to have more than --depth=1, and can save a lot of space
gpush() { if [ ! -d .git ]; then echo "Current folder is not a git repository (no .git folder is present)"; else printf "\n\nPush current directory up to git repository.\nWill run the following (if choose to continue):\n\n=>  git status   =>  git add .  [add all files]    =>  git status  [pause to check]\n=>  git commit -m \"Update\"     =>  git status      =>  git push -u origin master \n\n"; read -p "Ctrl-C to quit or press any key to continue ..."; printf "\n"; "git status before adding files:"; git status; git add .; echo "git status after 'git add .'"; git status; git commit -m "Update"; printf "About to upload repository to github\n\n"; read -p "Ctrl-C to quit, or any key to push local project up to remote repository ..."; git push -u origin master; echo -e "\n"; fi; }
alias gitpush='gpush'; alias g-push='gpush'; alias gpull='git pull'; alias gitpull='gpull'; alias g-pull='gpull'
alias push='gpush'; alias pull='gpull'   # Also just set 'push' and 'pull' to default to these as use so much
getgituser() { curl -s https://api.github.com/users/$1/repos?per_page=1000 | grep git_url | awk '{print $2}'| sed 's/"\(.*\)",/\1/'; }   # Get all visible repositories for a given git account $1 https://stackoverflow.com/questions/42832359/how-to-search-repositories-with-github-api-v3-based-on-language-and-user-name
gitbranch() { git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'; }   # Parse a git branch

####################
# Package Management: Generic package management syntax for common tasks (apt/yum/dnf/dpkg/apk/zypper/snap/flatpak)
####################
# Only enable aliases/functions if the package management tool is present, skip everything else.
# ii (install/add), rr/uu (remove/uninstall/del), then use the prefix 'i' for other installer/package-management tasks:
# is (search), accepts regex, so 'is ^zsh' vs 'is zsh' filter packages.   ishow/iview/iinfo, display package details.   iprovides, find what packages provide a given command.
# isize (show package size), accepts regex, so 'isize zsh' shows *only* the exact package, but 'isize ^zsh' shows all packages starting 'zsh'

# The apt cache requires regular updating, so the upgrade subcommand is to upgrade existing installed applications. http://packages.debian.net/
# By contrast, dnf updates metadata every time you use the command, so the update and upgrade subcommands are interchangeable
# sudo dnf upgrade / update  # these are the same
# sudo apt purge zsh         # To remove an application and its config files
# Both apt and dnf (even with purge) don't remove data or configuration files in your home directory. To remove data from your home directory, you must do it manually (it's usually found in ~/.config and ~/.local).
# The "apt-get" command pretty much does the same thing as apt, but with simpler user feedback, making it useful when scripting and where the user may be using a terminal with minimal capabilities.
if type apt &> /dev/null 2>&1; then 
    alias ii='sudo apt install';   alias rr='sudo apt remove';   alias uu='sudo apt remove';   
    alias is='apt search';         alias ishow='apt show'; alias iinfo='apt show'; alias iview='apt show'
    alias iprovides='sudo apt-file search';      alias purge='sudo apt purge';   # iprovides here requires apt-file, but define this anyway (will result in error if not there, but then it's clear to install it). Note that apt-file is more accurate if you use the command's expected path
    isize() { apt-cache --no-all-versions show $1 | grep -e '^Package' -e '^Version' -e '^Size:'; }
    debgraph() { debtree $1 | dot -Tpng > $1.png; }   # Create dependency graph for a given package
    alias irepos='sudo grep -rhE ^deb /etc/apt/sources.list*; echo -e "\nsudo grep -rhE ^deb /etc/apt/sources.list*\nsudo apt-cache policy\n"'
fi

# YUM 'Yellowdog Updater Modified' (front-end tool for RPM), DNF 'Dandified YUM', both mostly written in Python
# YUM had long-standing issues, undocumented API, poor performance, and bad dependency resolution, fixed in DNF and Python 3 compatible.
# DNF uses 'libsolv' for dependency resolution, Satisfiability (SAT)-based dependency solver, developed and maintained by SUSE to improve performance.
# Many RPM-based distros feature installation groups, which is convenient to install a batch of related apps
# sudo dnf group list -v   # sudo dnf group install design-suite   # sudo dnf install @design-suite   # @ indicates that this is a group
if type yum &> /dev/null 2>&1; then
    alias ii='sudo yum install';     alias ig='sudo yum group install';   alias rr='sudo yum remove';   alias uu='sudo yum remove';
    alias is='yum search';           alias igl='yum group list -v';       alias ishow='yum info'; alias iinfo='yum info'; alias iview='yum info';
    alias iprovides='sudo yum provides';      alias purge='sudo yum purge';
    isize() { yum info $1 | grep -e '^Package' -e '^Version' -e '^Size:'; };
    alias irepos='yum repolist; echo -e "\nyum repolist\nyum repolist all\nyum repolist enabled\nyum repolist disabled\nyum repolist available\n"'
    iirpm='sudo rpm -i';     rrrpm='sudo rpm -e';
fi
if type dnf &> /dev/null 2>&1; then
    alias ii='sudo dnf install';     alias ig='sudo dnf group install';   alias rr='sudo dnf remove';  alias uu='sudo dnf remove';
    alias is='dnf search';           alias igl='dnf group list -v';       alias ishow='dnf info'; alias iinfo='dnf info'; alias iview='dnf info';
    alias iprovides='sudo dnf provides';      alias purge='sudo dnf purge';
    isize() { dnf info $1 | grep -e '^Package' -e '^Version' -e '^Size:'; };
    alias irepos='dnf repolist; echo -e "\ndnf repolist\ndnf repolist all\ndnf repolist enabled\ndnf repolist disabled\ndnf repolist available\n"'
fi

# Include further distros here ...
# APK on Alpine/Busybox, # apk, does not require 'sudo' as root in alpine
if type apk &> /dev/null 2>&1; then
    alias ii='apk add'; alias rr='apk del'; alias uu='apk del'
    alias irepos='vi /etc/apk/repositories'
fi   

# Create some additional aliases based on the above:
# install, inst, setup => ii     uninstall, uninst, remove, delete => rr   (don't use 'del' as it maps to a Windows command)

if type ii > /dev/null 2>&1; then alias install='ii'; inst='ii'; alias setup='ii'; fi   # map inst / setup to ii, but only if it already exists (do not use 'install' as it is a built-in on Ubuntu)
if type rr > /dev/null 2>&1; then uninstall='rr'; alias uninst='rr'; alias remove='rr'; alias delete='rr'; fi   # map remove / del to rr, but only if ii already exists

if type aptitude >/dev/null 2>&1; then        # Only create aliases if aptitude is present
    alias tude-install='sudo aptitude install';              alias tude-remove='sudo aptitude remove';
    alias tude-purge='sudo aptitude purge';                  alias tude-hold='sudo aptitude hold';
    alias tude-unhold='sudo aptitude unhold';                alias tude-markauto='sudo aptitude markauto';
    alias tude-unmarkauto='sudo aptitude unmarkauto';        alias tude-forbid-version='sudo aptitude forbid-version';
    alias tude-update='sudo aptitude update';                alias tude-upgrade='sudo aptitude safe-upgrade';
    alias tude-full-upgrade='sudo aptitude full-upgrade';    alias tude-build-dep='sudo aptitude build-dep';
    alias tude-forget-new='sudo aptitude forget-new';        alias tude-search='sudo aptitude search';
    alias tude-show='sudo aptitude show';                    alias tude-clean='sudo aptitude clean';
    alias tude-autoclean='sudo aptitude autoclean';          alias tude-changelog='sudo aptitude changelog';
    alias tude-download='sudo aptitude download';            alias tude-reinstall='sudo aptitude reinstall';
    alias tude-why='sudo aptitude why';                      alias tude-why-not='sudo aptitude why-not';
    alias tude-linux-image='sudo aptitude search linux-image' # linux-image kernel update check;
fi
if type apt-cache >/dev/null 2>&1; then       # Only create aliases if apt-cache is present
    alias ac-add='sudo apt-cache add';                  alias ac-policy='sudo apt-cache policy';
    alias ac-gencaches='sudo apt-cache gencaches';      alias ac-showpkg='sudo apt-cache showpkg';
    alias ac-showsrc='sudo apt-cache showsrc';          alias ac-stats='sudo apt-cache stats';
    alias ac-dump='sudo apt-cache dump';                alias ac-dumpavail='sudo apt-cache dumpavail';
    alias ac-unmet='sudo apt-cache unmet';              alias ac-search='sudo apt-cache search';
    alias ac-show='sudo apt-cache show';                alias ac-depends='sudo apt-cache depends';
    alias ac-rdepends='sudo apt-cache rdepends';        alias ac-pkgnames='sudo apt-cache pkgnames';
    alias ac-dotty='sudo apt-cache dotty';              alias ac-xvcg='sudo apt-cache xvcg';
fi
if type apt-history >/dev/null 2>&1; then     # Only create aliases if apt-cache is present
    alias apth='apt-history';                           alias apthi='apt-history install';
    alias apthu='apt-history upgrade';                  alias apthr='apt-history remove';
    alias apthback='apt-history rollback'
fi    
if type apt >/dev/null 2>&1; then             # Only create aliases if apt is present (but see 'updistro' below)
    alias aupdate='sudo apt update && sudo apt upgrade'
    alias dupdate='sudo apt update && sudo apt upgrade'
fi
if type apt >/dev/null 2>&1 && type deborphan >/dev/null 2>&1; then
    alias aclean='sudo apt autoclean && sudo apt autoremove && sudo deborphan -Z && sudo apt clean'
    alias dclean='sudo apt autoclean && sudo apt autoremove && sudo deborphan -Z && sudo apt clean'
fi

updistro() {    # Self-contained function, no arguments, perform all update/upgrade functions for the current distro
    type apt    &> /dev/null && manager=apt    && DISTRO="Debian/Ubuntu"
    type yum    &> /dev/null && manager=yum    && DISTRO="RHEL/Fedora/CentOS"
    type dnf    &> /dev/null && manager=dnf    && DISTRO="RHEL/Fedora/CentOS"   # $manager should be dnf if both dnf and yum are present
    type zypper &> /dev/null && manager=zypper && DISTRO="SLES"
    type apk    &> /dev/null && manager=apk    && DISTRO="Alpine"
    function separator() { echo -e "\n>>>>>>>>\n"; }
    function displayandrun() { echo -e "\$ ${@/eval/}\n"; "$@"; }          # Show a command to run, and then run it, useful for showing progress during scripts

    printf "\nCheck updates:"
    echo -e "\n\n>>>>>>>>    A '$DISTRO' package manager was found, therefore,"
    echo -e     ">>>>>>>>    we will use the '$manager' package manager for setup tasks."
    if [ "$manager" == "apt" ]; then separator; displayandrun sudo apt --fix-broken install -y; fi   # Check and fix any broken installs, do before and after updates
    if [ "$manager" == "apt" ]; then separator; displayandrun sudo apt dist-upgrade -y; fi
    if [ "$manager" == "apt" ]; then separator; displayandrun sudo apt-get update --ignore-missing -y; fi     # Note sure if this is needed
    if [ "$manager" == "apt" ]; then type apt-file &> /dev/null && separator && displayandrun sudo apt-file update; fi   # update apt-file cache but only if apt-file is present
    if [ "$manager" == "apk" ]; then
        separator; displayandrun apk update; separator; displayandrun apk upgrade
    else
        separator; displayandrun sudo $manager update
        separator; displayandrun sudo $manager upgrade      # Note that on dnf, update/upgrade are the same command
        separator; displayandrun sudo $manager install ca-certificates -y   # To allow SSL-based applications to check for the authenticity of SSL connections
        separator; displayandrun sudo $manager autoremove
    fi
    if [ "$manager" == "apt" ]; then separator; displayandrun sudo apt --fix-broken install -y; fi   # Check and fix any broken installs, do before and after updates
    if [ -f /var/run/reboot-required ]; then
        echo "A reboot is required (/var/run/reboot-required is present)." >&2
        echo "Re-run this script after reboot to check." >&2
        return
    fi
    echo ""
}

pt() {
    # 'package tool', arguments are a list of package names to try. e.g. pt vim dfc bpytop htop
    # Determine if packages are already installed, fetch distro package list to see what is available, and then install the difference
    # If '-auto' or '--auto' is in the list, will install without prompts. e.g. pt -auto vlc emacs
    # Package names can be different in Debian/Ubuntu vs RedHat/Fedora/CentOS. e.g. python3.9 in Ubuntu is python39 in CentOS
    arguments="$@"; isinrepo=(); isinstalled=(); caninstall=(); notinrepo=(); toinstall=""; packauto=0; endloop=0;
    [[ $arguments == *"--auto"* ]] && packauto=1 && arguments=$(echo $arguments | sed 's/--auto//')   # enable switch and remove switch from arguments
    [[ $arguments == *"-auto"* ]] && packauto=1 && arguments=$(echo $arguments | sed 's/-auto//')     # must do '--auto' before '-auto' or will be left with a '-' fragment
    mylist=("$arguments")   # Create array out of the arguments.    mylist=(python3.9 python39 mc translate-shell how2 npm pv nnn alien angband dwarf-fortress nethack-console crawl bsdgames bsdgames-nonfree tldr tldr-py bpytop htop fortune-mod)
    # if declare -p $1 2> /dev/null | grep -q '^declare \-a'; then echo "The input \$1 must be an array"; return; fi   # Test if the input is an array
    type apt &> /dev/null && manager="apt" && apt list &> /dev/null > /tmp/all-repo.txt && apt list --installed &> /dev/null > /tmp/all-here.txt && divider="/"
    type dnf &> /dev/null && manager="dnf" && dnf list &> /dev/null > /tmp/all-repo.txt && dnf list installed   &> /dev/null > /tmp/all-here.txt && divider=""
    type dnf &> /dev/null && manager="dnf" && dnf list &> /dev/null > /tmp/all-repo.txt && dnf list installed   &> /dev/null > /tmp/all-here.txt && divider=""
    for x in ${mylist[@]}; do grep "^$x$divider" /tmp/all-repo.txt &> /dev/null && isinrepo+=($x); done    # find items available in repo
    # echo -e "These are in the repo: ${isinrepo[@]}\n\n"   # $(for x in ${isinrepo[@]}; do echo $x; done)
    for x in ${mylist[@]}; do grep "^$x$divider" /tmp/all-here.txt &> /dev/null && isinstalled+=($x); done # find items already installed
    notinrepo+=(`echo ${mylist[@]} ${isinrepo[@]} | tr ' ' '\n' | sort | uniq -u `)  # get the diff from two arrays, jave have to consider the right arrays to use here # different answer here: https://stackoverflow.com/a/2315459/524587
    echo ""
    [[ ${isinrepo[@]} != "" ]]    && echo "These packages exist in the $manager repository:            ${isinrepo[@]}"   # $(for x in ${isinstalled[@]}
    [[ ${isinstalled[@]} != "" ]] && echo "These packages are already installed on this system:   ${isinstalled[@]}"   # $(for x in ${isinstalled[@]}
    [[ ${notinrepo[@]} != "" ]]   && echo "These packages do not exist in the repository:         ${notinrepo[@]}"     # $(for x in ${isinstalled[@]}

    caninstall+=(`echo ${isinrepo[@]} ${isinstalled[@]} | tr ' ' '\n' | sort | uniq -u `)  # get the diff from two arrays (use "${}" if spaces in array elements) # https://stackoverflow.com/a/28161520/524587
    if [ $packauto = 1 ]; then
        if (( ${#caninstall[@]} )); then sudo $manager install -y ${caninstall[@]}   # Test the number of elements, if non-zero then enter the loop
        else echo -e "\nNo selected packages can be installed. Exiting ...\n"
        fi
        return
    fi
    
    while [ $endloop = 0 ]; do
        caninstall=(Install-and-Exit)
        caninstall+=(`echo ${isinrepo[@]} ${isinstalled[@]} | tr ' ' '\n' | sort | uniq -u `)  # get the diff # https://stackoverflow.com/questions/2312762/compare-difference-of-two-arrays-in-bash#comment52200489_28161520
        if [[ ${caninstall[@]} = "Install-and-Exit" ]]; then echo -e "\nNo new packages exist in the repository to be installed. Exiting ...\n"; return; fi
        COLUMNS=12
        [[ $toinstall != "" ]] && echo -e "\n\nCurrently selected packages:   $toinstall"
        echo -e "\n\nSelect a package number to add to the install list.\nTo install the selected packages and exit the tool, select '1'.\n"
        printf -v PS3 '\n%s ' 'Enter number of package to install: '
        select x in ${caninstall[@]}; do
            toinstall+=" $x "
            toinstall=$(echo $toinstall | sed 's/Install-and-Exit//' | tr ' ' '\n' | sort -u | xargs)   # https://unix.stackexchange.com/a/353328/441685
            if [ $x == "Install-and-Exit" ]; then endloop=1; fi
            break
        done
    done
    if [[ $toinstall = *[!\ ]* ]]; then    # https://unix.stackexchange.com/a/147109/441685
        echo -e "\n\n\nAbout to run:   sudo $manager install $toinstall\n\n"
        read -p "Press Ctrl-C to skip installation or press any key to install the package(s) ..."
        sudo $manager install -y $toinstall
    else
        echo -e "\nNo selected packages can be installed. Exiting ...\n"
    fi
}

####################
# App related and larger functions: some, like espeak/mogrify, only activate if those packages are present, so they do not clutter the environment if those packages are missing
####################
# Try never overwrite a base command with an alias, should only be done very rarely, currently only doing for cat, less, tree, mainly for terminal color options
# Using color on console is very useful when visually looking through output, but there is an issue that the control codes are sent through the pipe.
# e.g.   bat x.js -pp | jq   will hit a problem. Fix that using   | perl -pe 's/\e([^\[\]]|\[.*?[a-zA-Z]|\].*?\a)//g' | col -b   to remove color and control characters from output, https://unix.stackexchange.com/q/14684/
#        bat x.js -pp | perl -pe 's/\e([^\[\]]|\[.*?[a-zA-Z]|\].*?\a)//g' | col -b | jq
# or     bat x.js -pp | uncolor | jq     # with:   uncolor() { perl -pe 's/\e([^\[\]]|\[.*?[a-zA-Z]|\].*?\a)//g' | col -b; }
# It might be posible to do everything in 'bat' with 'less', possibly use this in future:   https://www.topbug.net/blog/2016/09/27/make-gnu-less-more-powerful/
type bat >/dev/null 2>&1 && alias cat='bat -pp' && alias ca='\cat' && alias ba='\bat' # If 'bat' exists on the system, replace 'cat' by 'bat -pp'. If you don't want this, 'unalias cat' to revert to normal 'cat'
[ ! -f /usr/bin/bat ] && unalias cat 2>/dev/null && unalias ca 2>/dev/null && unalias ba 2>/dev/null   # Don't really need this, just how to remove if bat is uninstalled
# When using bat as a cat replacement, 'cat .custom | more' is fine, but less requires the -R (or -r) switch to maintain colour syntax highlighting
type less >/dev/null 2>&1 alias less='less -R'; alias less0='\less'; alias more='less'   # Colour always supported, even through pipe. Also alias 'more' to 'less', as 'more' is pretty useless
type tree >/dev/null 2>&1 && alias tree='tree -C' && alias tree0='\tree'                      # Colour always, and so piping to less -R will retain color output
type pydf >/dev/null 2>&1 && alias df1='pydf'        # Use <cmd>1, <cmd>2, for variants, do this for other commands with alternatives
type ncdu >/dev/null 2>&1 && alias du1='ncdu'        # Same for du1, we use <cmd>. for built-in functions in .custom (e.g. du. etc)
# Most systems have 'python2' and 'python3' defined. Debian/Ubuntu use python2 for underlying system functions
# 'python' points to python2 in Debian/Ubuntu, but RHEL/CentOS8 does not have a copy of python2 at all
# In the below, set 'python' to 'python3' by default, but remember that aliases/functions defined here only exist in the currect interative login
# Note: 'python3.8' / 'python3.9' to start those versions, and 'pip2' does not exist on Ubuntu20+ or RHEL/CentOS8+ by default (note that the package is called 'python3-pip' on both distros)
alias python='python3'; alias p='python3'; alias pip='pip3'; alias p2='python2'; alias p3='python3'; alias p36='python3'; alias p38='python3.8'; alias p39='python3.9'
# Terminal Web tools, limited usefulness, test elinks, links2, w3m also, ideally would like to return various information to terminal if possible
py2web() { [ -z "$1" ] && echo "No port specified, defaulting to port 8000"; python2 -m SimpleHTTPServer $1; echo "Python Web Server started as background job with PID $!"; }   # https://serverfault.com/questions/205498/how-to-get-pid-of-just-started-process
py3web() { if [ -z "$1" ]; then echo "No port specified, defaulting to port 8000"; port=8000; else port=$1; fi; python3 -m http.server $1; echo -e "\nnetstat -tulpn $(netstat -tulpn)\nss -tulw $(ss -tulw)\n"; }
py3web-example() { py=py3web-example.py; [ ! -f "~/$py" ] && [ -f /tmp/.custom/$py ] && cp /tmp/.custom/$py ~/; [ -f ~/$py ] && python3 ~/$py $1 || echo "Python Server Example ($py) was not found"; }
alias term-google='lynx http://google.co.uk'; alias term-google0='lynx -term=vt100 http://google.co.uk'   # --term=vt100 = black and white
alias term-bbc='lynx https://news.bbc.co.uk/text_only.stm'; alias term-bbc0='lynx -term=vt100 https://news.bbc.co.uk/text_only.stm'
alias term-theregister='lynx https://theregister.com'; alias term-theregister0='lynx -term=vt100 https://theregister.com'
alias pc='python -ic "from __future__ import division; from math import *"'   # 'Python calculator', opens python with settings useful for quick calculations (similar to bc, but also with correct calculations, i.e. 1/2 = 0.5 instead of 0).
type espeak >/dev/null 2>&1 && alias espeak-wav-file='espeak -s 150 -w voice.wav -f' && alias espeak-wav='espeak -s 150 -w voice.wav' && alias espeak-us='espeak -v en-us -s 150' && alias espeak-file='espeak -s 150 -f'   # Only created if espeak present
type mogrify >/dev/null 2>&1 && alias webify="mogrify -resize 690 *.png"   # resize all PNG in current folder only if wider than 690px using ImageMagick
alias tastatur="setxkbmap -model cherryblue -layout de -variant ,nodeadkeys"   # for changing keyboards, sample
type notify-send >/dev/null 2>&1 && alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

extract () {   # Extract any archive type into a folder
    local x
    function ee() { echo "$@"; $1 "$2"; }   # echo and execute
    for x in "$@"; do
        [[ -f $x ]] || continue
        case "$x" in
            *.tar.bz2 | *.tbz2 ) ee "tar xvjf" "$x" ;; *.tar.gz | *.tgz ) ee "tar xvzf" "$x"   ;; *.bz2 )  ee "bunzip2" "$x" ;;
            *.rar )              ee "unrar x" "$x"  ;; *.gz )             ee "gunzip" "$x"     ;; *.tar )  ee "tar xvf" "$x" ;;
            *.zip )              ee "unzip" "$x"    ;; *.Z )              ee "uncompress" "$x" ;; *.7z )   ee "7z x" "$x"    ;;
        esac
    done
}
targz() { tar -zcvf $1.tar.gz $1; }   # Create $1.tar.gz from file/directory $1,  can optionally add '; rm -r $1;' at end to remove the original files
untargz() { tar -zxvf $1; }           # Extract a .tar.gz,  can optionally add '; rm -r $1;' at end to remove the archive
mktar() { tar cvf  "${1%%/}.tar"     "${1%%/}/"; }      # Create tar from given directory
mktgz() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }      # Create tar.gz
mktbz() { tar cvjf "${1%%/}.tar.bz2" "${1%%/}/"; }      # Create tar.bz
mkzip() { zip -r "${1%%/}.zip" "$1" ; }                 # Create zip archive of a file or folder.
gzipsize() { echo $((`gzip -c $1 | wc -c`/1024))"KB"; } # Calculates the gzip compression of a file
# Bash profile loading is as follows: /etc/profile (which often calls /etc/bash.bashrc), then ~/.bash_profile, then ~/.bash_login, then ~/.profile (which often calls ~/.bashrc)
backup_profile() {
    ARCHIVE="$HOME/bash_dotfiles_$(date +%Y%m%d_%H%M%S).tar.gz"; 
    FILES=; SUDOTHIS=;
    [ "$1" = "-root" ] && for i in /etc/profile /etc/bash.bashrc /etc/inputrc /etc/vimrc; do [ -f $i ] && FILES="$FILES $i"; SUDOTHIS="sudo "; done
    for i in ~/.bash_profile ~/.bash_login ~/.bash_logout ~/.profile ~/.bashrc ~/.inputrc ~/.vimrc ~/.bash_functions ~/.bash_aliases ~/.bash_prompt ~/.custom; do [ -f $i ] && FILES="$FILES $i"; done
    echo $FILES; [ "$1" = "-root" ] && echo "root files were backed up" || echo "root files were not backed up"
    exe $SUDOTHIS tar -czvf $ARCHIVE $FILES; echo "All backed up in $ARCHIVE"
}
bu() { cp "$1" "$1".backup-`date +%y%m%d-%H%M`; echo "`date +%Y-%m-%d %H-%M` backed up $PWD/$@" >> ~/.backups.log; }   # Create in place backup of a file and record that in ~/.backups.log
json() { cat "$@" | /usr/bin/python -m json.tool; }    # supply a JSON, it will check it for consitency using python

pswatch() { watch -n 1 'ps -eo pid,ppid,%mem,%cpu,cmd --sort=-%mem'; }   # A cut down 'top' using ps and watch
psmemory() { ps aux | awk '{if ($5 != 0 ) print $2,$5,$6,$11}' | sort -k2n; }
alias psg='ps aux | grep -v grep | grep -i -e VSZ -e'
alias psme='ps -ef | grep $USER --color=always'               # Show only my procs
myps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }  # 'my ps' ps for current user only
mypf() { myps f | awk '!/awk/ && $0~var' var=${1:-".*"} ; }   # 'my ps forest', f = ASCII art process hierarchy (forest).
mykill()   # Kill processes, but *only* from my process list (myps) for any matching name $1 (safety function to prevent killing critical processes by a typo on a PID)
{
    local pid pname sig="-TERM"   # default signal
    if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        echo "Usage: killps [-SIGNAL] pattern"
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(myps| awk '!/awk/ && $0~pat { print $1 }' pat=${!#} )
    do
        pname=$(myps | awk '$1~var { print $5 }' var=$pid )
        if ask "Kill process $pid <$pname> with signal $sig?"
            then kill $sig $pid
        fi
    done
}
ask()       # See 'killps' for example of use.
{
    echo -n "$@" '[y/n] ' ; read ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}
exe() { printf "\n\n"; echo "\$ ${@/eval/}"; "$@"; }  # Show the command to be run before running, useful for outputs when scripting
square() { v1=$1; n=$(($v1*$v1)); echo $n; }          # Maths function
expo() { v1=$1; v2=$2; n=$(($v1**$v2)); echo $n; }    # Maths function, also note the built in 'factor' what a number is divisible by
factorial() { v1=$1; n=1; while [[ $v1 -gt 0 ]]; do n=$(($n*$v1)); v1=$(($v1 - 1)); done; echo $n; }  # Maths function
color256() { curl -s 0- https://gist.githubusercontent.com/HaleTom/89ffe32783f89f403bba96bd7bcd1263/raw/ | bash; }   # Run script from url
runfromurl() { curl -s $2 > $1; chmod a+x $1; ls -l $1; if [ $3 = "print" ]; then cat "./$1"; fi; if [ $3 = "run" ]; then exec "./$1"; fi; }

ver() { [ -f /etc/redhat-release ] && RELEASE=$(cat /etc/redhat-release); [ -f /etc/lsb-release ] && RELEASE="$(cat /etc/lsb-release | grep DESCRIPTION | sed 's/^.*=//g' | sed 's/\"//g') "; printf "$RELEASE: $(uname -msr)\n"; }
sys() { awk -F": " '/^model name/ { mod=$2 } /^cpu MHz/ { mhz=$2 } /^cpu core/ {core=$2} /^flags/ { virt="No Virtualisation";match($0,"svm");if (RSTART!=0) { virt="SVM-Virtualisation" };match($0,"vmx");if (RSTART!=0) { virt="VMX-Virtualisation" } } /^Mem:/ {split($2,arr," ");tot=arr[1];free=arr[2]} END { printf "%s, %dMHz, %s core(s), %s, %sB Memory (%sB Used)\n",mod,mhz,core,virt,tot,free }' /proc/cpuinfo <(free -mh); printf "$(hostname -I),$(uptime)\n"; }   # Excellent sed tutorial https://linuxhint.com/newline_replace_sed/
type apk &> /dev/null && sys() { awk -F": " '/^model name/ { mod=$2 } /^cpu MHz/ { mhz=$2 } /^cpu core/ {core=$2} /^flags/ { virt="No Virtualisation";match($0,"svm");if (RSTART!=0) { virt="SVM-Virtualisation" };match($0,"vmx");if (RSTART!=0) { virt="VMX-Virtualisation" } } /^Mem:/ {split($2,arr," ");tot=arr[1];free=arr[2]} END { printf "%s, %dMHz, %s core(s), %s, %sB Memory (%sB Used)\n",mod,mhz,core,virt,tot,free }' /proc/cpuinfo <(free -mh); printf "$(ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p' | sed 'H;1h;$!d;x;y/\n/,/'),$(uptime)\n"; }   # Excellent sed tutorial https://linuxhint.com/newline_replace_sed/

# Vim and useful text file discovery tools
alias vimlast="vim -c \"normal '0\""    # Open last file (even if you changed directory)
vi.() { COLUMNS=12; printf -v PS3 '\n%s ' 'Select option: '; printf "Edit config file (note interactive: /etc/profile, then .bash_profile or .bash_login or .profile, https://tinyurl.com/startuporder):\n\n"; select x in ~/.bash_profile ~/.bash_login ~/.bash_logout ~/.profile ~/.bashrc ~/.custom ~/.inputrc ~/.vimrc; do vim $x; break; done; }   # Edit dot conf files
vi.su() { COLUMNS=12; printf -v PS3 '\n%s ' 'Select option: '; printf "Edit config file with sudo (note interactive: /etc/profile, then .bash_profile or .bash_login or .profile, https://tinyurl.com/startuporder):\n\n"; select x in vim\ /etc/profile vim\ /etc/bash.bashrc vim\ /etc/bashrc vim\ /etc/inputrc vim\ /etc/vimrc vim\ /etc/hosts vim\ /etc/samba/smb.conf visudo; do sudo $x; break; done; }   # Edit system dot conf files
alias decomment='egrep -v "^[[:space:]]*((#|;|//).*)?$" '    # Display a file, but stripped of all comments
alias unprintable='grep --color="auto" -P -n "[\x00-\x1E]" ' # Display unprintable control characters in a file, strip unprintable from file:   tr -cd "[:print:]" < {{filename}}
alias expletives='grep --color="auto" -P -n "[^\x00-\x7E]" ' # Display chars above ASCII 127, which include curly brackets from web pages or Word documents
alias datestring='date +"%Y-%m-%d__%H-%M-%S"'                # YYYYY-MM-DD__HHH-Min-Sec format, synta for when need to add a datestring to a filename output
:h() { vim --cmd ":silent help $@" --cmd "only"; }           # Access help for a vim command from the console

# figclock() { while [ 1 ]; do clear; printf "\e[33m"; df -kh; printf "\e[31m\n"; top -n 1 -b | head -13 | tail -11; printf "\e[33m$(figlet -w -t -f small $(date +"%b %d, week %V"))\n"; [ -f /usr/share/figlet/univers.flf ] && local opts="-f univers" || local opts="-f big"; printf "\e[94m$(figlet -k -t $opts $(date +"%H:%M:%S"))\e[00m\n"; printf "\e[35m5 second intervals, Ctrl-C to quit.\e[00m"; sleep 5; done; }
# figclock() { while [ 1 ]; do clear; printf "\e[33m"; df -kh; printf "\e[31m\n"; top -n 1 -b | head -13 | tail -11; printf "\e[33m$(figrnd $(date +"%b %d, week %V"))\n"; printf "\e[94m$(figrnd $(date +"%H:%M:%S"))\e[00m\n"; printf "\e[35mRefreshes every 5 seconds (Ctrl-C to quit).\e[00m"; sleep 5; done; }
# TOIlet stands for “The Other Implementation's letters", coined after FIGlet’s “Frank, Ian and Glen’s letters".
type figlet  &> /dev/null && figall() { for f in /usr/share/figlet/*.flf; do fs=$(basename $f); fname=${fs%%}; echo "$fname"; figlet -f $fname $fname; done; }
type figlet  &> /dev/null && figrandom() { rand=$(ls /usr/share/figlet/*.flf | sort -R | tail -1); printf "$(echo $rand | awk -F'/' '{print $NF}')\n"; }   # 'sort -R' is random, also note 'shuf'
type figlet  &> /dev/null && fignow() { printf "\e[33m$(figlet -w -t -f /usr/share/figlet/small.flf $(date +"%a, %d %b, wk%V"))"; [ -f /usr/share/figlet/univers.flf ] && local opts="-f /usr/share/figlet/univers.flf" || local opts="-f /usr/share/figlet/big.flf"; printf "\e[94m$(figlet -t $opts $(date +"%H:%M"))\e[00m\n"; }   # date "%b %d, week %V"
type figlet  &> /dev/null && figclock() { while [ 1 ]; do clear; printf "\e[33m"; df -kh; printf "\e[31m\n"; top -n 1 -b | head -11; printf "\e[33m$(figlet -w -t -f small $(date +"%b %d, week %V"))\n"; printf "\e[94m$(figrandom $(date +"%H:%M:%S"))\e[00m\n"; printf "\e[35m5 second intervals, Ctrl-C to quit.\e[00m"; sleep 5; done; }
type cowsay  &> /dev/null && cowrandom() { if [ -d /usr/share/cowsay/cows/ ]; then files=/usr/share/cowsay/cows/*; else files=/usr/share/cowsay/*; fi; printf "%s\n" "${files[RANDOM % ${#files}]}"; }
type cowsay  &> /dev/null && cowall() { if [ -d /usr/share/cowsay/cows/ ]; then files=/usr/share/cowsay/cows/*.cow; else files=/usr/share/cowsay/*.cow; fi; echo $files; for f in $files; do printf "\n\n\n\n\n$f\n\n"; fortune | cowsay -f $f; done; }   # https://stackoverflow.com/questions/12320521/simple-bash-for-f-in#12320617
type cowsay  &> /dev/null && alias fcow="fortune | cowsay -f $(cowrandom)"   # -b Borg, -d dead, -g greedy, -p paranoia, -s stoned, -t tired, -w wired mode, -y brings youthful
type cowsay  &> /dev/null && cowmix() { if [ -d /usr/share/cowsay/cows/ ]; then files=(/usr/share/cowsay/cows/*.cow); else files=(/usr/share/cowsay/*.cow); fi; while IFS= read -d $'\0' -r file; do fortune | cowsay -f "$file"; echo -e "$file\n"; sleep 3; done < <(printf '%s\0' "${files[@]}" | shuf -z); }
type ponysay &> /dev/null && ponyrandom() { if [ -d /usr/share/ponysay/ponies/ ]; then files=/usr/share/ponysay/ponies/*; else files=/usr/share/ponysay/*; fi; printf "%s\n" "${files[RANDOM % ${#files}]}"; }
type ponysay &> /dev/null && ponyall() { if [ -d /usr/share/ponysay/ponies/ ]; then files=/usr/share/ponysay/ponies/*.pony; else files=/usr/share/ponysay/*.pony; fi; echo $files; for f in $files; do printf "\n\n\n\n\n$f\n\n"; fortune | ponysay -f $f; sleep 2; done; }   # https://stackoverflow.com/questions/12320521/simple-bash-for-f-in#12320617
type ponysay &> /dev/null && alias fpony="fortune | ponysay -f $(ponyrandom)"
type ponysay &> /dev/null && ponymix() { files=(/usr/share/ponysay/ponies/*.pony); while IFS= read -d $'\0' -r file; do fortune | ponysay -f "$file" -b round 2> /dev/null; echo -e "$file\n"; sleep 3; done < <(printf '%s\0' "${files[@]}" | shuf -z); }
type toilet  &> /dev/null && toiletgayclock() { echo "$(date '+%D %T' | toilet -f `figrandom` -F border --gay)"; }
type toilet  &> /dev/null && toiletmetalclock() { echo "$(date '+%D %T' | toilet -f `figrandom` -F border --metal)"; }
type toilet  &> /dev/null && tom() { toilet -f term --metal; } && tog() { toilet -f term --gay; }  # pipe anything to these for the --metal / --gay effect
type lolcat  &> /dev/null && alias lcat='lolcat' && alias lcata='lolcat -a -d 9'    # pip to lol to colour anything, more advanced than toilet effect
artscene() { curl -s http://artscene.textfiles.com/vt100/$1.vt --limit-rate 9600; echo -e "\n\n\nAvailable art-files at http://artscene.textfiles.com/vt100/:\n"; lynx -dump http://artscene.textfiles.com/vt100/ | cut -d'.' -f4 | cut -d'/' -f3 | grep -v -e '^ ' -e 'References' -e '^[[:space:]]*$' | tr '\n' ','; }   #  Alternative way to slow rate:  | pv -q -L 9600
knights() { URL=https://genius.com/Monty-python-the-knights-who-say-ni-annotated; content=$(wget $URL -q -O -); lynx -dump $URL | sed -n '/HEAD/,/Aaaaugh/p' | pv -qL 50; }
RGB() { awk 'BEGIN{ s="          "; s=s s s s s s s s; for (colnum = 0; colnum<77; colnum++) { r = 255-(colnum*255/76); g = (colnum*510/76); b = (colnum*255/76); if (g>255) g = 510-g; printf "\033[48;2;%d;%d;%dm", r,g,b; printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b; printf "%s\033[0m", substr(s,colnum+1,1); } printf "\n";}'; }   # test-rgb awk script
colortail() { tail -F $*|ccze -A; }
alias ct='colortail'
alias userinfo='getent passwd|column  -t -s: -n'
alias groupinfo='getent group|column  -t -s: -n'
alias rsync.='rsync -ravz'
alias rsync.ssh='rsync -e ssh'
setup-starship-prompt() { sh -c "$(curl -fsSL https://starship.rs/install.sh)"; }   # https://github.com/starship/starship
setup-angel-PS1-prompt() { wget https://github.com/dolmen/angel-PS1/raw/release/angel-PS1; eval `./angel-PS1`; }
# https://github.com/chris-marsh/pureline   https://github.com/powerline/powerline   https://github.com/dolmen/angel-PS1

####################
# Networks:   https://www.tecmint.com/command-line-tools-to-monitor-linux-performance/
####################
alias n.info-cli='echo "pt iftop iptstate net-tools lsof nmap whois iptraf-ng arpwatch vnstat"'
alias n.info-gui='echo "pt monit nethogs monitorix vnstatphp nagios"'   # vnstat-php https://www.tecmint.com/vnstat-php-frontend-for-monitoring-network-bandwidth/
alias n.info-open-ports='echo -e "sudo lsof -i -P -n | grep LISTEN\nsudo netstat -tulpn | grep LISTEN\nsudo ss -tulpn | grep LISTEN\nsudo lsof -i:22 ## see a specific port such as 22 ##\nsudo nmap -sTU -O IP-address-Here"'
alias r.="route"
alias ip.="type ifconfig &>/dev/null && ifconfig; ip addr show -c"
alias ip4="ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'"   # need to escape $2 when putting in alias. Alternatively:   ifconfig | grep "inet" | awk '{print $2}' | grep -v '::' | grep -v '127.0.0.1'      ip addr show | grep inet | grep -v inet6 | grep -v 127.0.0.1 | awk '{print \$2}' | cut -d/ -f1"
alias ip6="ip addr show | grep inet | grep -v 'inet ' | grep -v ::1/ | awk '{print \$2}' | cut -d/ -f1"   # need to escape $2 when putting in alias
alias ipexternam='dig +short myip.opendns.com @resolver1.opendns.com'
ipup-ping() { for ip in $(seq 1 254); do ping -c 1 192.168.1.$ip>/dev/null; [ $? -eq 0 ] && echo "192.168.1.$ip UP" || : ; done; }
ipup-nmap() { nmap -n -sn 192.168.1.0/24 -oG - | awk '/Up$/{print $2}'; }   # Very fast # -n turns off reverse name resolution, as on local LAN this is probably the slowest step, -sn means "Don't do a port scan.", -oG - sends "grepable" output to stdout, which gets piped to awk.
alias pong='ping -i 0.2 -s 2'
alias nmap.='sudo nmap -sT -O localhost' # more here http://www.redhat.com/docs/manuals/linux/RHL-9-Manual/security-guide/s1-server-ports.html
alias ping='ping -c 4'
alias whois='whois -H'
alias eth0down="sudo ifdown eth0"; alias eth0up="sudo ifup eth0"
get-domain-info() { domains=$@; if [[ $# -eq 0 ]]; then echo "Usage: $0 test.com example.com ..."; exit 1; fi; for d in $domains; do ip=$(host $d | grep 'has add' | head -1 | awk '{ print $4}'); [ "$ip" == "" ] && { echo "Error: An error occurred!"; continue; }; echo -e "\033[93mGetting information about domain: $d [ $ip ] \033[0m"; whois "$ip" | \egrep -w 'OrgName:|City:|Country:|OriginAS:|NetRange:'; echo ""; done; }
alias iftop.="sudo iftop -Pp -i eth0"
alias ipt.="sudo iptstate -l -1"
alias ipt?="sudo iptstate -l -1 | grep"
alias pingr="ping `netstat -nr| grep -m 1 -iE 'default|0.0.0.0' | awk '{print $2}'`"   # ping router
export sn=`netstat -nr | grep -m 1 -iE 'default|0.0.0.0' | awk '{print $2}' | sed 's/.[0-9]*$//' `   # Can then do: ping $sn.31 for 192.168.1.31
alias netstat1='sudo netstat -tulpan'
alias netstat2='netstat -tua'
alias netstat3="netstat -alnp --protocol=inet | grep -v CLOSE_WAIT | cut -c-6,21-94 | tail"
alias netstat4='netstat -an | sed -n "1,/Active UNIX domain sockets/ p" | more'
alias netstatw1='watch --interval=2 "sudo netstat -apn -l -A inet"'              # netstat watch 1
alias netstatw2='watch --interval=2 "sudo netstat -anp --inet --inet6"'          # netstat watch 2
alias netstatw3='watch --interval=2 "sudo netstat -p -e --inet --numeric-hosts"' # netstat watch 3
alias netstatw4='watch --interval=2 "sudo netstat -tulpan"'                      # netstat watch 4
alias netstatw5='watch --interval=2 "sudo netstat -utapen"'                      # netstat watch 5
alias netstatw6='watch --interval=2 "sudo netstat -ano -l -A inet"'              # netstat watch 6
alias limpets='nmap -sP $(ip -o addr show | grep inet  | grep eth | cut -d  -f 7)'   # all IPs connected to my network
alias lsof.='sudo lsof -i'
alias iptlistfw='sudo /sbin/iptables -L FORWARD -n -v –line-numbers'   # iptables might be redundant
alias what-port='echo -e "See /etc/services for complete list\n20 FTP data transfer\n21 FTP session\n22 SSH\n23 Telnet\n25 SMTP email\n43 WHOIS\n53 DNS\n67 DHCP server\n68 DHCP client\n80 HTTP\n110 POP3 email\n119 NNTP\n123 NTP\n137 NETBIOS nameservice\n138 NETBIOS datagram\n139 NETBIOS session\n143 IMAP email\n161 SNMP\n162 SNMP trap\n194 IRC\n443 HTTPS over TLS/SSL\n587 SMTP email\n873 rsync"'

####################
# Personal Settings:   # Personal settings that will be overwritten by "~/.custom-me' if that file is present
####################
alias reload='pushd . > /dev/null; cd ~/custom_bash; source custom_loader.sh; cd - > /dev/null'   # cd - internally does a cd $OLDPWD
alias cd0="cd ~/custom_bash; ls"       # Adjust to personal main projects for convenience, can set cd1, cd2, etc
alias cd1="cd /tmp/.custom; ls *.sh"   # Another personal location to jump to (location of .custom backups and help files etc)
alias cd2="cd ~/custom_tools; ls"      # Another peronal project location
alias cd0edit="pushd . > /dev/null; cd ~/custom_bash; code .custom custom_loader.sh more_apps.sh README.md; cd - > /dev/null"
alias cd1edit="pushd . > /dev/null; cd ~/custom_bash; code .custom custom_loader.sh more_apps.sh README.md; cd - > /dev/null"
alias hp2="ssh boss@192.168.1.31"      # CentOS home server, create other quick links, and setup .ssh/config and ssh keys to make it easy to hop between systems
alias upload="sftp username@server.com:/path/to/upload/directory"   # Adjust this alias to suit upload needs
alias myip="curl http://ipecho.net/plain; echo"   # Alternatively, alias myip='curl -s http://whatismyip.akamai.com/'   # get public IP address when behind a router using NAT
alias play='nvlc /path/to/music/ -Z'   # Requires VLC, plays a random collection of music from your music library.
alias weather-ams='curl -4 http://wttr.in/Amsterdam'
alias weather-ny='curl -4 http://wttr.in/NewYork'
# defverb() { lynx -dump "http://www.google.com/search?hl=en&q=define%3A+${1}&btnG=Google+Search" | sed -n '/^   verb$/,${p;/^$/q}'; }   # https://ubuntuforums.org/showthread.php?t=679762&page=2
# defwiki() { lynx -dump "http://en.wikipedia.org/wiki/${1} | head -50"; }
me="~/.custom-me"; [[ -f $me ]] && source $me   

####################
# Help Topics:   Created at /tmp/.custom by custom_loader.sh and then aliased
####################
hhtmp='/tmp/.custom'             # could replace 'help' with '?', as this is allowed in bash, 'grep?' etc is a valid alias name
for helpfile in $hhtmp/help-*.sh; do aliasname=$(echo $helpfile | cut -d'/' -f4 | cut -d'.' -f1); alias "$aliasname"="$helpfile"; done
for helpfile in $hhtmp/help-*.sh; do aliasname=$(echo $helpfile | cut -d'/' -f4 | cut -d'.' -f1 | sed 's/help-/h-/'); alias "$aliasname"="$helpfile"; done
for helpfile in $hhtmp/help-*.sh; do aliasname=$(echo $helpfile | cut -d'/' -f4 | cut -d'.' -f1 | sed 's/help-/h/'); alias "$aliasname"="$helpfile"; done
help-cron-intro-1999()    { URL=http://www.unixgeeks.org/security/newbie/unix/cron-1.html;               content=$(wget $URL -q -O -); lynx -dump $URL | less; }   # Just a uawdul demonstration to read a web page
help-cron-intro-karatos() { URL=https://blog.karatos.in/a?ID=00850-8984d093-c8c8-4bc7-a7c4-c4bfa805d59a; content=$(wget $URL -q -O -); lynx -dump $URL | less; }
help-git-basics()         { URL=https://blog.karatos.in/a?ID=00000-389ae5ea-acc9-489c-842c-02e9179cfcb6; content=$(wget $URL -q -O -); lynx -dump $URL | less; }
help-git-pro()            { URL=https://blog.karatos.in/a?ID=00000-c9118532-abc2-423f-8b92-a94a740c251e; content=$(wget $URL -q -O -); lynx -dump $URL | less; }

hhliq="$hhtmp/liquid.sh"; [[ -f $hhliq ]] && alias liquid="source $hhliq"   # Can source a script from an alias/function created during .bashrc
hh="$hhdk/.custom-dk"; [[ -f $hhdk ]] && alias dk="if type docker &> /dev/null; then echo -e 'Docker was found; adding dk aliases from $hhdk\n$(type docker)'; source $hhdk; else 'Docker is not installed'; fi"     # Not enabled by default, running dk will initialise the .customdk aliases/functions, including re-aliasing itself as dk => docker
# Trivial but can be nice to have (on Ubuntu these are already available in repository)
type dnf &>/dev/null && install-all-toys() { sudo dnf install ruby install gcc make automake autoconf curl-devel openssl-devel zlib-devel httpd-devel apr-devel apr-util-devel sqlite-devel ruby-devel rubygems; sudo gem install lolcat; } # https://gist.github.com/mtaziz/d5b2f9ef46b06f04fbbd   g++ ruby-rdoc
type dnf &>/dev/null && install-acquarium() { echo "run script from /tmp/.custom"; }

####################
# WSL:   These will only activate if this session is in WSL, i.e. if /proc/version contains "Microsoft" or "WSL". https://stackoverflow.com/q/38086185/   https://meta.stackexchange.com/q/164194/
####################
if grep -qEi "(Microsoft|WSL)" /proc/version &> /dev/null; then
    alias shutdown='wsl.exe --terminate $WSL_DISTRO_NAME'   # To get around no systemd, this will properly terminate the running WSL instance
    alias reboot='cd /mnt/c/ && cmd.exe /c start "Rebooting WSL"     cmd /c "timeout 5 && start wsl -d $WSL_DISTRO_NAME" && wsl.exe --terminate $WSL_DISTRO_NAME'
    # Shutting down or rebooting WSL https://stackoverflow.com/questions/66375364/shutdown-or-reboot-a-wsl-session-from-inside-the-wsl-session/67090137#67090137
    # 1. There is no systemd in WSL, so distros cannot use standard shutdown/reboot or any other actions dependent upon systemd.
    # 2. Closing a WSL window will *not* shutdown the WSL engine. The WSL instance and any services continues to run in the background.
    # 3. There are times when it is important to shutdown or reboot the full WSL instance for configuration changes, hence the following commands:
    alias x='explorer.exe'
    alias x.='explorer.exe .'
    alias xcloud='explorer.exe "D:\0 Cloud"'
    alias notepad++="'/mnt/c/Program Files/Notepad++/notepad++.exe'"   # notepad++ C:\Temp\Test.txt , 
    alias n++='notepad++'                                              # n C:\Temp\Test.txt
    # All of the below use + instead of %20 : real percent encoding uses %20 while form data in URLs is in a modified form that uses +. So you're most likely to only see + in URLs in the query string after a '?'. https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
    # Might need to replace more of these in 'urlfix', but mostly it should work just with: + %2B, ! %21, ? %3F then replace spaces with '+' at the end
    # Space	%20     :  %3A     ]  %5D     +  %2B     /  %2F     \  %5C     ‘  %27          
    # $  %24        <  %3C     {  %7B     #  %23     ;  %3B     ^  %5E     ,  %2C  
    # &  %26        >  %3E     }  %7D     %  %25     =  %3D     |  %7C          
    # `  %60        [  %5B     “  %22     @  %40     ?  %3F     ~  %7E          
    alias chrome="'/mnt/c/Program Files/Google/Chrome/Application/chrome.exe'"  # This alias will work with any URL:  chrome www.google.com
    alias firefox="'C:\Program Files\Mozilla Firefox\firefox.exe'"
    alias opera="'C:\Program Files\Opera\opera.exe'"
    # Can do a lot with 'gg' or 'ddg', e.g. 'gg weather amsterdam', 'gg 5/5!' 'gg 5 log 2' (very advanced scientific calculator, will handle almost any freeform calculation)
    # However, some useful speific use cases for youtube (yy), translation (tt), and dictionary use (dic / syn) can be handy.
    urlfix() { echo $(echo "$@" | sed 's/\+/%2B/g' | sed 's/\!/%21/g' | sed 's/\?/%3F/g' | sed 's/[ ][ ]*/\+/g'); }
    gg() { phrase=$(urlfix "$@"); echo $phrase; url="https://www.google.co.uk/search?q=${phrase}"; echo $url; chrome $url; }
    ddg() { phrase=$(urlfix "$@"); echo $phrase; url="https://www.duckduckgo.com/?q=${phrase}"; echo $url; chrome $url; }
    tt() { phrase=$(echo "$@" | sed 's/[ ][ ]*/\+/g'); url="https://www.google.co.uk/search?q=translate+$phrase"; type trans >/dev/null 2>&1 && trans -b "$@"; chrome $url; }   # tt conflicts with package 'treetop', but not something I would need
    ttnl() { phrase=$(echo "$@" | sed 's/[ ][ ]*/\+/g'); url="https://www.google.co.uk/search?q=translate+nl+$phrase"; type trans >/dev/null 2>&1 && trans -t nl -b "$@"; chrome $url; }
    tten() { phrase=$(echo "$@" | sed 's/[ ][ ]*/\+/g'); url="https://www.google.co.uk/search?q=translate+nl+$phrase"; type trans >/dev/null 2>&1 && trans -t en -b "$@"; chrome $url; }
    dic() { phrase=$(echo "$@" | sed 's/[ ][ ]*/\+/g'); url="https://www.google.co.uk/search?q=dictionary+$phrase"; type trans >/dev/null 2>&1 && trans -d "$@"; chrome $url; }
    syn() { phrase=$(echo "$@" | sed 's/[ ][ ]*/\+/g'); url="https://www.google.co.uk/search?q=synonym+$phrase"; echo $url; chrome $url; }
    yy() { phrase=$(echo "$@" | sed 's/[ ][ ]*/\+/g'); url="https://www.youtube.com/results?search_query=$phrase"; echo $url; chrome $url; } 
    ym() { if [[ -z "$1" ]]; then echo "Enter a search string!"; else mpv "$(youtube-dl --default-search 'ytsearch1:' \"$1\" --get-url | tail -1)"; fi }
    # transw() { phrase=$(echo $1 | sed 's/[ ][ ]*/%20/g');  [ type trans ] && trans -t en -b "$@"; chrome "https://translate.google.com/?sl=auto&tl=en&text=${phrase}&op=translate"; }
    # weather() { lynx -dump http://www.google.com/search?q=weather+$1+$2+$3 | grep -E "($1|°)" | grep -v '\[' | head -3; }
    # weather7() { for (( i=0; i<7; ++i)); do day=$(date --date="+$i day" +"%a"); weather $1 $2 $i; done; }
    # lynx -dump https://www.thomascook.com/holidays/weather/amsterdam/forecast/ | awk '/1\./{y=1;next}y' | sed '/View weather for/,$d'
    # '1' stands for 'one-liners', useful as an entry point to looking up info, also note 'gg grep delete all lines after match' free form searches from terminal
    alias awk1='chrome https://duckduckgo.com/?q=awk+one+liners; chrome https://catonmat.net/awk-one-liners-explained-part-one; chrome http://softpanorama.org/Tools/Awk/awk_one_liners.shtml; chrome https://www.shebanglinux.com/best-awk-one-liners/'
    alias grep1='chrome https://duckduckgo.com/?q=grep+one+liners; chrome https://www.richud.com/wiki/Grep_one_liners; chrome https://lagooko.blogspot.com/2015/12/grep-handy-one-liner.html; chrome https://adminoneliner.blogspot.com/2015/12/grep-command-one-liners.html'
    alias sed1='chrome https://duckduckgo.com/?q=sed+one+liners; chrome https://edoras.sdsu.edu/doc/sed-oneliners.html; chrome http://www.unixguide.net/unix/sedoneliner.shtml; chrome https://catonmat.net/sed-one-liners-explained-part-one'
    alias python1='chrome https://duckduckgo.com/?q=python+one-liners; chrome https://pythonbooks.org/free-books/; chrome https://automatetheboringstuff.com/; chrome https://www.geeksforgeeks.org/powerful-one-liner-python-codes/; chrome https://blog.finxter.com/10-python-one-liners/'
    alias perl1='chrome https://duckduckgo.com/?q=perl+one+liners; chrome https://devtut.github.io/perl/perl-one-liners.html#execute-some-perl-code-from-command-line; chrome http://www.softpanorama.org/Scripting/Perlorama/perl_one_liners.shtml; chrome https://www.socher.org/perloneliners; chrome https://gist.github.com/joyrexus/7328094; chrome https://perl1liner.sourceforge.io/;'
    alias bash1='chrome https://duckduckgo.com/?q=bash+one+liners; chrome https://onceupon.github.io/Bash-Oneliner/; chrome http://www.bashoneliners.com/; chrome https://catonmat.net/bash-one-liners-explained-part-one'
    alias mygit='chrome https://github.com/roysubs/custom_bash; chrome https://github.com/roysubs/Custom-Tools; chrome https://github.com/roysubs/Basics-AHK'
    alias cartoons="chrome https://xkcd.com; chrome https://townhall.com/political-cartoons; chrome http://stonetoss.com/comic/"
    alias usnews-subs='echo "Subscription paywall sites, using archive.ph"; chrome https://archive.ph/https://www.nytimes.com/; chrome https://archive.ph/https://www.washingtonpost.com/; chrome https://archive.ph/https://www.newyorker.com/'   # To update: use 'foreach i in arry-of-news-sites, prefix https://archive.ph/ and then open that'
    alias uknews-subs='echo "Subscription paywall sites, using archive.ph"; chrome https://archive.ph/https://www.spectator.co.uk/; chrome https://archive.ph/https://www.telegraph.co.uk/; chrome https://archive.ph/http://thetimes.co.uk/; chrome https://archive.ph/https://www.scotsman.com/; chrome https://archive.ph/https://www.newscientist.com/'
    alias weatherxx="curl -s 'http://rss.accuweather.com/rss/liveweather_rss.asp?metric=1&locCode=en|nl|amsterdam|11215' | sed -n '/Currently:/ s/.*: \(.*\): \([0-9]*\)\([CF]\).*/\2°\3, \1/p'"   # might not work

    # Map common Windows locations to navigate to from within WSL. Use ':' on these mappings to identify as WSL mappings to Windows
    # Map c: to /mnt/c, d: to /mnt/d, e: to /mnt/e etc but only if those paths exist   # [ -d /mnt/c ] && alias c:='cd /mnt/c'
    for d in /mnt/[a-z]; do [ -d /mnt/$(basename ${d}) ] && alias "$(basename ${d}):"="cd $d"; done         #  "d:" => cd to /mnt/d
    for d in /mnt/[a-z]; do [ -d /mnt/$(basename ${d}) ] && alias "l$(basename ${d}):"="cd $d && ll"; done   # "ld:" => cd to and list d:""
    [ -d /mnt/c/Windows/System32 ] && alias sys32:='cd /mnt/c/Windows/System32 && sudo ls'
    [ -d /mnt/c/Program\ Files ] && alias pf:='cd /mnt/c/Program\ Files && ls' && alias pf64:='cd /mnt/c/Program\ Files && ls'
    [ -d /mnt/c/Program\ Files\ \(x86\) ] && alias pf32:='cd /mnt/c/Program\ Files\ \(x86\) && ls' && alias pf86:='cd /mnt/c/Program\ Files\ \(x86\) && ls'
    [ -d /mnt/d/0\ Cloud ] && alias cloud:='cd /mnt/d/0\ Cloud && ls'
    # Linux is case-sensitive, but Windows is case-insensitive. What if user is 'john' in Linux, but 'John' in Windows?
    # If set completion-ignore-case On is in .inputrc, this is not a problem, but otherwise it is so use the following to handle this:
    alias home:='cd $(find /mnt/c/Users -maxdepth 1 -type d -regextype posix-extended -iregex /mnt/c/users/$USER)'

    # Microsoft already provides a "code" shell script to call from WSL, so do not use code.exe from a full installation or from chocolatey
    # shim at /mnt/c/ProgramData/chocolatey/bin/code.exe, as these will cause errors inside WSL. Only use one of the official "code" shell script.
    # Below checks might be redundant; does WSL come up in a state that it can see VS Code already?
    # [ -f /mnt/c/tools/vscode/bin/code ] && alias code='/mnt/c/tools/vscode/bin/code'   # Default Portable Edition location with Chocolatey package
    # [ -f /mnt/c/Program\ Files/Microsoft\ VS\ Code/bin/code ] && alias code="/mnt/c/Program Files/Microsoft\ VS\ Code/bin/code"   # Default System install location
    # [ -f /mnt/c/Users/$USER/AppData/Local/Programs/Microsoft\ VS\ Code/bin/code ] && alias code="/mnt/c/Users/${USER}/AppData/Local/Programs/Microsoft\ VS\ Code/bin/code"   # Default User install location

    # Demonstrate Windows clip.exe and Get-Clipboard within WSL to send to or get from the Windows clipboard (remember Ctrl-Shift-V to paste the clipboard back onto WSL console)
    alias cliptowindows='clip.exe'   # Usage:   hostname -I | cliptowindows     to send the IP address into the clipboard
    alias pastefromwindows='powershell.exe -noprofile Get-Clipboard'   # Note '.exe' in powershell.exe. Usage:   pastefromwindows | grep 'word'

    # Run a CMD script in WSL; *must* use the Windows path, so run-cmd D:\test.cmd, and not run-cmd /mnt/d/test.cmd   https://github.com/microsoft/WSL/issues/4547
    run-cmd() { CMD=$1; shift; ARGS=$@; WIN_PWD=`wslpath -w "$(pwd)"`; cmd.exe /c "pushd ${WIN_PWD} && ${CMD} ${ARGS}"; }
    # Run a PS script in WSL; *must* use the Windows path, so run-ps D:\test.ps1, and not run-ps /mnt/d/test.ps1
    run-ps() { CMD=$1; shift; ARGS=$@; WIN_PWD=`wslpath -w "$(pwd)"`; powershell.exe /c "pushd ${WIN_PWD}; ${CMD} ${ARGS}"; }

    # X Window GUI support. As with all of this section, will *only* set if WSL is detected (so will not affect a non-WSL install).
    # https://sourceforge.net/projects/vcxsrv/. During VcXsrv setup, leave DISPLAY as "-1" (for autodetect) and it will see WSL2.
    # Run 'xeyes &' to test (always use '&' to background any X app so that it does not hold the WSL terminal while running). https://nickjanetakis.com/blog/using-wsl-and-mobaxterm-to-create-a-linux-dev-environment-on-windows#wsl-conemu-and-mobaxterm-to-the-rescue
    export DISPLAY="$(/sbin/ip route | awk '/default/ { print $3 }'):0"
    alias term='xterm -bg AntiqueWhite -fg Black &';                    alias termb='xterm -bg AntiqueWhite -fg NavyBlue &'
    alias termg='xterm -bg AntiqueWhite -fg OliveDrab &';               alias termr='xterm -bg AntiqueWhite -fg DarkRed &'
    alias aterm='xterm -ls -fg gray -bg black';                         alias xtop='xterm -fn 6x13 -bg LightSlateGray -fg black -e top &'
    alias xsu='xterm -fn 7x14 -bg DarkOrange4 -fg white -e su &'
fi

####################
# Display login banner, except for when starting a new tmux/byobu session)
####################
login_banner() { printf "\n$(RGB)\n$(ver) : $(date +"%Y-%m-%d, %H:%M:%S, %A, Week %V")\n$(sys)\n"; type figlet >/dev/null 2>&1 && fignow; }

[ -z "$TMUX" ] && login_banner   # Only display login_banner if this is not a new tmux session
# [ -z "$TMUX" ] && export TERM=xterm-256color && exec tmux   # Optional: Always start tmux at login, but skip when running a new tmux session